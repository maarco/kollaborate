#!/bin/zsh
# Kollaborate CLI - Autonomous Multi-Agent Development Framework
# Usage: kollaborate <command> [options]

set -e

KOLLABORATE_HOME="${KOLLABORATE_HOME:-$(dirname "$(realpath "$0")")}"
KOLLABORATE_VERSION="1.0.0"

# MAXIMUM BRIGHTNESS - Lime and Cyan theme with BOLD
CYAN='\033[1;38;2;0;255;255m'    # BOLD + Maximum bright cyan (RGB)
LIME='\033[1;38;2;0;255;0m'      # BOLD + Maximum bright lime green (RGB)
NC='\033[0m' # No Color

# Legacy color names mapped to new scheme
RED="$LIME"
GREEN="$LIME"
YELLOW="$LIME"
BLUE="$CYAN"

print_banner() {
    echo "${CYAN}"
    echo "╔══════════════════════════════════════════════════════╗"
    echo "║                                                      ║"
    echo "║   ██╗  ██╗ ██████╗ ██╗     ██╗      █████╗ ██████╗   ║"
    echo "║   ██║ ██╔╝██╔═══██╗██║     ██║     ██╔══██╗██╔══██╗  ║"
    echo "║   █████╔╝ ██║   ██║██║     ██║     ███████║██████╔╝  ║"
    echo "║   ██╔═██╗ ██║   ██║██║     ██║     ██╔══██║██╔══██╗  ║"
    echo "║   ██║  ██╗╚██████╔╝███████╗███████╗██║  ██║██████╔╝  ║"
    echo "║   ╚═╝  ╚═╝ ╚═════╝ ╚══════╝╚══════╝╚═╝  ╚═╝╚═════╝   ║"
    echo "║                Autonomous Multi-Agent                ║"
    echo "║             Development Framework v${KOLLABORATE_VERSION}             ║"
    echo "╚══════════════════════════════════════════════════════╝"
    echo "${NC}"
}

print_help() {
    print_banner
    echo "Usage: kollaborate <command> [options]"
    echo ""
    echo "Commands:"
    echo "  ${GREEN}init${NC}              Initialize Kollaborate in current directory"
    echo "  ${GREEN}start${NC} [agents]    Start the agent watcher daemon"
    echo "  ${GREEN}status${NC}            Show current task and agent status"
    echo "  ${GREEN}add${NC} <type> <task> Add a new task to the queue"
    echo "  ${GREEN}use${NC} <backend>     Switch LLM backend (claude, gemini, crush, codex, etc.)"
    echo "  ${GREEN}prompt${NC}            Generate AI assistant context for Kollaborate"
    echo "  ${GREEN}help${NC}              Show this help message"
    echo "  ${GREEN}version${NC}           Show version information"
    echo ""
    echo "Task Types:"
    echo "  ${CYAN}feature${NC} (F##)      New functionality"
    echo "  ${CYAN}refactor${NC} (R##)     Code quality, restructuring"
    echo "  ${CYAN}bug${NC} (B##)          Fixes, corrections"
    echo "  ${CYAN}test${NC} (T##)         Test coverage, improvements"
    echo "  ${CYAN}doc${NC} (D##)          Documentation, comments"
    echo "  ${CYAN}perf${NC} (P##)         Performance optimization"
    echo "  ${CYAN}arch${NC} (A##)         Architecture, design"
    echo "  ${CYAN}security${NC} (S##)     Security hardening"
    echo "  ${CYAN}hotfix${NC} (H##)       Urgent production fixes"
    echo "  ${CYAN}migration${NC} (M##)    Database/data migrations"
    echo "  ${CYAN}integration${NC} (I##)  Third-party integrations"
    echo "  ${CYAN}chore${NC} (C##)        Maintenance, dependencies"
    echo "  ${CYAN}experiment${NC} (E##)   POC, spike work"
    echo "  ${CYAN}ux${NC} (U##)           User experience"
    echo "  ${CYAN}validation${NC} (V##)   Data validation, schemas"
    echo "  ${CYAN}workflow${NC} (W##)     CI/CD, automation"
    echo "  ${CYAN}exploration${NC} (X##)  Research tasks"
    echo ""
    echo "Options:"
    echo "  --max-agents <n>      Maximum concurrent task agents (default: 3)"
    echo "  --max-spec-agents <n> Maximum spec generation agents (default: 2)"
    echo "  --project-type <type> Project type hint (node, python, rust, go, etc.)"
    echo ""
    echo "Examples:"
    echo "  kollaborate init                    # Initialize in current directory"
    echo "  kollaborate init --project-type node"
    echo "  kollaborate start 3 2               # Start with 3 task agents, 2 spec agents"
    echo "  kollaborate add feature \"User authentication\" src/auth.js"
    echo "  kollaborate add bug \"Fix memory leak\" src/pool.js"
    echo "  kollaborate add test \"API integration tests\" tests/api.test.js"
    echo ""
}

detect_project_type() {
    local project_dir="$1"

    # Check for various project indicators
    if [[ -f "$project_dir/package.json" ]]; then
        if grep -q "typescript" "$project_dir/package.json" 2>/dev/null; then
            echo "typescript"
        else
            echo "node"
        fi
    elif [[ -f "$project_dir/Cargo.toml" ]]; then
        echo "rust"
    elif [[ -f "$project_dir/go.mod" ]]; then
        echo "go"
    elif [[ -f "$project_dir/requirements.txt" ]] || [[ -f "$project_dir/pyproject.toml" ]] || [[ -f "$project_dir/setup.py" ]]; then
        echo "python"
    elif [[ -f "$project_dir/pom.xml" ]] || [[ -f "$project_dir/build.gradle" ]]; then
        echo "java"
    elif [[ -f "$project_dir/Gemfile" ]]; then
        echo "ruby"
    elif [[ -f "$project_dir/composer.json" ]]; then
        echo "php"
    elif [[ -f "$project_dir/Package.swift" ]]; then
        echo "swift"
    elif [[ -f "$project_dir/pubspec.yaml" ]]; then
        echo "dart"
    else
        echo "generic"
    fi
}

get_build_commands() {
    local project_type="$1"

    case "$project_type" in
        node|typescript)
            cat << 'EOF'
```bash
# Install dependencies
npm install

# Run development server
npm run dev

# Run tests
npm test

# Run linting
npm run lint

# Build for production
npm run build
```
EOF
            ;;
        python)
            cat << 'EOF'
```bash
# Create virtual environment
python -m venv venv
source venv/bin/activate

# Install dependencies
pip install -r requirements.txt

# Run application
python main.py

# Run tests
pytest

# Run linting
flake8 . && black --check .
```
EOF
            ;;
        rust)
            cat << 'EOF'
```bash
# Build project
cargo build

# Run project
cargo run

# Run tests
cargo test

# Check for errors
cargo check

# Format code
cargo fmt

# Run clippy lints
cargo clippy
```
EOF
            ;;
        go)
            cat << 'EOF'
```bash
# Download dependencies
go mod download

# Build project
go build ./...

# Run project
go run .

# Run tests
go test ./...

# Format code
go fmt ./...

# Run linter
golangci-lint run
```
EOF
            ;;
        java)
            cat << 'EOF'
```bash
# Build project (Maven)
mvn clean install

# Run project
mvn spring-boot:run

# Run tests
mvn test

# Build project (Gradle)
./gradlew build

# Run tests (Gradle)
./gradlew test
```
EOF
            ;;
        ruby)
            cat << 'EOF'
```bash
# Install dependencies
bundle install

# Run application
bundle exec ruby main.rb

# Run tests
bundle exec rspec

# Run linting
bundle exec rubocop
```
EOF
            ;;
        php)
            cat << 'EOF'
```bash
# Install dependencies
composer install

# Run development server
php artisan serve

# Run tests
./vendor/bin/phpunit

# Run linting
./vendor/bin/phpcs
```
EOF
            ;;
        swift)
            cat << 'EOF'
```bash
# Build project
swift build

# Run project
swift run

# Run tests
swift test
```
EOF
            ;;
        dart)
            cat << 'EOF'
```bash
# Get dependencies
dart pub get

# Run application
dart run

# Run tests
dart test

# Analyze code
dart analyze
```
EOF
            ;;
        *)
            cat << 'EOF'
```bash
# [Add your build commands here]
# Example:
# make build
# make test
# make run
```
EOF
            ;;
    esac
}

get_default_structure() {
    local project_type="$1"

    case "$project_type" in
        node|typescript)
            echo "src/, tests/, config/"
            ;;
        python)
            echo "src/, tests/, config/"
            ;;
        rust)
            echo "src/, tests/"
            ;;
        go)
            echo "cmd/, internal/, pkg/, tests/"
            ;;
        java)
            echo "src/main/, src/test/, config/"
            ;;
        *)
            echo "src/, tests/, config/"
            ;;
    esac
}

get_task_type_prefix() {
    local task_type="$1"

    case "$task_type" in
        feature|feat|f) echo "F" ;;
        refactor|ref|r) echo "R" ;;
        bug|fix|b) echo "B" ;;
        test|tests|t) echo "T" ;;
        doc|docs|documentation|d) echo "D" ;;
        perf|performance|optimize|p) echo "P" ;;
        arch|architecture|a) echo "A" ;;
        security|sec|s) echo "S" ;;
        hotfix|hot|h) echo "H" ;;
        migration|migrate|m) echo "M" ;;
        integration|integrate|i) echo "I" ;;
        chore|maintenance|c) echo "C" ;;
        experiment|exp|spike|e) echo "E" ;;
        ux|ui|u) echo "U" ;;
        validation|validate|val|v) echo "V" ;;
        workflow|cicd|w) echo "W" ;;
        exploration|explore|research|x) echo "X" ;;
        *) echo "" ;;
    esac
}

get_next_task_number() {
    local task_type_prefix="$1"

    if [[ ! -f "TASK_TRACKING.md" ]]; then
        echo "1"
        return
    fi

    # Find the highest number for this task type
    local max_num=$(grep -oE "${task_type_prefix}[0-9]+" TASK_TRACKING.md 2>/dev/null | sed "s/${task_type_prefix}//" | sort -n | tail -1)

    if [[ -z "$max_num" ]]; then
        echo "1"
    else
        echo "$((max_num + 1))"
    fi
}

get_sample_tasks() {
    local project_type="$1"
    local project_name="$2"

    case "$project_type" in
        node|typescript)
            cat << EOF
NEW: A1 - Initialize package.json with project dependencies and scripts (file: package.json)
NEW: A2 - Create environment configuration module with validation (file: src/config/env.js)
NEW: F1 - Setup application entry point with error handling (file: src/index.js)
NEW: F2 - Implement logging utility with multiple log levels (file: src/utils/logger.js)
NEW: F3 - Create base error classes for standardized error handling (file: src/utils/errors.js)
NEW: T1 - Add unit tests for logger utility (file: tests/utils/logger.test.js)
NEW: D1 - Document API endpoints and usage examples (file: docs/API.md)
EOF
            ;;
        python)
            cat << EOF
NEW: A1 - Initialize pyproject.toml with dependencies and metadata (file: pyproject.toml)
NEW: A2 - Create configuration module with environment variable loading (file: src/config.py)
NEW: F1 - Setup application entry point with argument parsing (file: src/main.py)
NEW: F2 - Implement logging configuration with formatters (file: src/utils/logger.py)
NEW: F3 - Create custom exception classes for error handling (file: src/utils/exceptions.py)
NEW: T1 - Add pytest suite for core modules (file: tests/test_main.py)
NEW: D1 - Document module structure and usage (file: docs/README.md)
EOF
            ;;
        rust)
            cat << EOF
NEW: A1 - Initialize Cargo.toml with dependencies and metadata (file: Cargo.toml)
NEW: A2 - Create configuration module with environment loading (file: src/config.rs)
NEW: F1 - Setup main entry point with error handling (file: src/main.rs)
NEW: F2 - Implement logging with tracing crate (file: src/logging.rs)
NEW: F3 - Create custom error types with thiserror (file: src/error.rs)
NEW: T1 - Add integration tests for core functionality (file: tests/integration_test.rs)
NEW: D1 - Document public API with rustdoc (file: src/lib.rs)
EOF
            ;;
        go)
            cat << EOF
NEW: A1 - Initialize go.mod with module path and dependencies (file: go.mod)
NEW: A2 - Create configuration package with env loading (file: internal/config/config.go)
NEW: F1 - Setup main entry point with graceful shutdown (file: cmd/main.go)
NEW: F2 - Implement structured logging with zerolog (file: internal/logger/logger.go)
NEW: F3 - Create custom error types with stack traces (file: internal/errors/errors.go)
NEW: T1 - Add table-driven tests for config package (file: internal/config/config_test.go)
NEW: D1 - Document package interfaces and examples (file: README.md)
EOF
            ;;
        *)
            cat << EOF
NEW: A1 - Initialize project configuration and dependencies (file: config/setup)
NEW: F1 - Create main application entry point (file: src/main)
NEW: F2 - Implement core business logic module (file: src/core)
NEW: F3 - Setup logging and monitoring utilities (file: src/utils/logger)
NEW: T1 - Create test suite for core functionality (file: tests/core_test)
NEW: D1 - Document project structure and usage (file: docs/README.md)
EOF
            ;;
    esac
}

cmd_init() {
    local project_dir="$(pwd)"
    local project_name="$(basename "$project_dir")"
    local project_type="${PROJECT_TYPE:-$(detect_project_type "$project_dir")}"

    print_banner

    echo "${BLUE}[INIT]${NC} Initializing Kollaborate in: ${CYAN}$project_dir${NC}"
    echo "${BLUE}[INIT]${NC} Detected project type: ${CYAN}$project_type${NC}"
    echo ""

    # Create directory structure
    echo "${YELLOW}[STEP 1/2]${NC} Creating directory structure..."

    if [[ ! -d "specs" ]]; then
        mkdir -p specs
        echo "  ${GREEN}+${NC} Created specs/"
    else
        echo "  ${YELLOW}~${NC} specs/ already exists"
    fi

    # Verify KOLLABORATE_HOME is set
    echo ""
    echo "${YELLOW}[STEP 2/2]${NC} Verifying Kollaborate installation..."

    if [[ -z "$KOLLABORATE_HOME" ]]; then
        echo "  ${RED}!${NC} Error: KOLLABORATE_HOME not set"
        echo "  ${RED}!${NC} Please run the installation script first"
        exit 1
    fi

    if [[ ! -f "$KOLLABORATE_HOME/kollaborate.sh" ]]; then
        echo "  ${RED}!${NC} Error: kollaborate.sh not found at $KOLLABORATE_HOME"
        echo "  ${RED}!${NC} Please reinstall Kollaborate"
        exit 1
    fi

    echo "  ${GREEN}✓${NC} Found daemon at $KOLLABORATE_HOME/kollaborate.sh"

    # Create TASK_TRACKING.md
    echo ""
    echo "${YELLOW}[TASK]${NC} Creating task tracking file..."

    if [[ ! -f "TASK_TRACKING.md" ]]; then
        cat > TASK_TRACKING.md << EOF
# $project_name Development Log

## Current Goal
[Describe your project's primary objective here]

## Build & Development Commands
$(get_build_commands "$project_type")

## Project Structure
$(get_default_structure "$project_type")

## Development Log

$(get_sample_tasks "$project_type" "$project_name")
EOF
        echo "  ${GREEN}+${NC} Created TASK_TRACKING.md with sample tasks"
    else
        echo "  ${YELLOW}~${NC} TASK_TRACKING.md already exists (skipped)"
    fi

    # Add specs/ to .gitignore
    echo ""
    if [[ -f ".gitignore" ]]; then
        if ! grep -q "specs/" ".gitignore" 2>/dev/null; then
            echo "" >> .gitignore
            echo "# Kollaborate specifications" >> .gitignore
            echo "specs/" >> .gitignore
            echo "  ${GREEN}+${NC} Added specs/ to .gitignore"
        fi
    fi

    echo ""
    echo "${GREEN}════════════════════════════════════════════════════════════════${NC}"
    echo "${GREEN}  Kollaborate initialized successfully!${NC}"
    echo "${GREEN}════════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo "Next steps:"
    echo "  1. Edit ${CYAN}TASK_TRACKING.md${NC} to define your project goal and tasks"
    echo "  2. Run ${CYAN}kollaborate start${NC} to begin autonomous development"
    echo ""
    echo "Quick commands:"
    echo "  ${CYAN}kollaborate start${NC}        - Start with default settings (3 agents)"
    echo "  ${CYAN}kollaborate start 5 2${NC}    - Start with 5 task agents, 2 spec agents"
    echo "  ${CYAN}kollaborate status${NC}       - Check current progress"
    echo ""
}

cmd_start() {
    local max_agents="${1:-3}"
    local max_spec_agents="${2:-2}"

    # Check if TASK_TRACKING.md exists (project is initialized)
    if [[ ! -f "TASK_TRACKING.md" ]]; then
        echo "${RED}[ERROR]${NC} Kollaborate not initialized in this directory"
        echo "Run ${CYAN}kollaborate init${NC} first"
        exit 1
    fi

    # Verify KOLLABORATE_HOME is set
    if [[ -z "$KOLLABORATE_HOME" ]]; then
        echo "${RED}[ERROR]${NC} KOLLABORATE_HOME not set"
        echo "Please run the installation script first"
        exit 1
    fi

    if [[ ! -f "$KOLLABORATE_HOME/kollaborate.sh" ]]; then
        echo "${RED}[ERROR]${NC} Daemon not found at $KOLLABORATE_HOME/kollaborate.sh"
        echo "Please reinstall Kollaborate"
        exit 1
    fi

    print_banner
    echo "${BLUE}[START]${NC} Launching agent watcher daemon..."
    echo "${BLUE}[START]${NC} Daemon: ${CYAN}$KOLLABORATE_HOME/kollaborate.sh${NC}"
    echo "${BLUE}[START]${NC} Max task agents: ${CYAN}$max_agents${NC}"
    echo "${BLUE}[START]${NC} Max spec agents: ${CYAN}$max_spec_agents${NC}"
    echo ""

    exec "$KOLLABORATE_HOME/kollaborate.sh" "$max_agents" "$max_spec_agents"
}

cmd_status() {
    if [[ ! -f "TASK_TRACKING.md" ]]; then
        echo "${RED}[ERROR]${NC} TASK_TRACKING.md not found"
        exit 1
    fi

    print_banner

    echo "${BLUE}[STATUS]${NC} Task Overview"
    echo "════════════════════════════════════════"
    echo ""

    local new_count
    local working_count
    local done_count
    local qa_count

    # Count all task types using pattern [FRBDTPASHMIICEUVWX][0-9]+
    new_count=$(grep -c "^NEW: [FRBDTPASHMICEUVWX][0-9]" TASK_TRACKING.md 2>/dev/null) || new_count=0
    working_count=$(grep -c "^WORKING: [FRBDTPASHMICEUVWX][0-9]" TASK_TRACKING.md 2>/dev/null) || working_count=0
    done_count=$(grep -c "^DONE: [FRBDTPASHMICEUVWX][0-9]" TASK_TRACKING.md 2>/dev/null) || done_count=0
    qa_count=$(grep -c "^QA: [FRBDTPASHMICEUVWX][0-9]" TASK_TRACKING.md 2>/dev/null) || qa_count=0

    echo "${YELLOW}Pending:${NC}    $new_count tasks"
    echo "${CYAN}Working:${NC}    $working_count tasks"
    echo "${GREEN}Completed:${NC}  $done_count tasks"
    echo "${BLUE}In QA:${NC}      $qa_count tasks"
    echo ""

    if [[ $working_count -gt 0 ]]; then
        echo "${CYAN}Active Tasks:${NC}"
        grep "^WORKING: [FRBDTPASHMICEUVWX][0-9]" TASK_TRACKING.md | while read -r line; do
            echo "  - $line"
        done
        echo ""
    fi

    if [[ $new_count -gt 0 ]]; then
        echo "${YELLOW}Pending Tasks:${NC}"
        grep "^NEW: [FRBDTPASHMICEUVWX][0-9]" TASK_TRACKING.md | head -5 | while read -r line; do
            echo "  - $line"
        done
        if [[ $new_count -gt 5 ]]; then
            local remaining=$((new_count - 5))
            echo "  ... and $remaining more"
        fi
        echo ""
    fi

    # Check for active agents
    if command -v tlist &> /dev/null; then
        echo "${BLUE}Active Agents:${NC}"
        tlist 2>/dev/null | grep "•" || echo "  No active agents"
        echo ""
    fi
}

cmd_add() {
    local task_type="$1"
    local task_desc="$2"
    local file_path="$3"

    if [[ -z "$task_type" ]] || [[ -z "$task_desc" ]]; then
        echo "${RED}[ERROR]${NC} Task type and description required"
        echo "Usage: kollaborate add <type> \"<description>\" [file]"
        echo ""
        echo "Types: feature, refactor, bug, test, doc, perf, arch, security,"
        echo "       hotfix, migration, integration, chore, experiment, ux,"
        echo "       validation, workflow, exploration"
        echo ""
        echo "Examples:"
        echo "  kollaborate add feature \"User authentication\" src/auth.js"
        echo "  kollaborate add hotfix \"Critical payment bug\" src/payment.js"
        echo "  kollaborate add migration \"Add user roles table\" migrations/"
        exit 1
    fi

    if [[ ! -f "TASK_TRACKING.md" ]]; then
        echo "${RED}[ERROR]${NC} TASK_TRACKING.md not found"
        exit 1
    fi

    # Get task type prefix
    local prefix=$(get_task_type_prefix "$task_type")

    if [[ -z "$prefix" ]]; then
        echo "${RED}[ERROR]${NC} Invalid task type: $task_type"
        echo "Valid types: feature, refactor, bug, test, doc, perf, arch, security,"
        echo "             hotfix, migration, integration, chore, experiment, ux,"
        echo "             validation, workflow, exploration"
        exit 1
    fi

    # Find next number for this task type
    local next_num=$(get_next_task_number "$prefix")
    local task_id="${prefix}${next_num}"

    # Build task line
    local task_line="NEW: $task_id - $task_desc"

    if [[ -n "$file_path" ]]; then
        task_line="$task_line (file: $file_path)"
    fi

    # Add the task
    echo "$task_line" >> TASK_TRACKING.md

    echo "${GREEN}[ADDED]${NC} $task_id - $task_desc"

    if [[ -n "$file_path" ]]; then
        echo "${BLUE}[FILE]${NC}  $file_path"
    fi
}

cmd_version() {
    echo "Kollaborate v${KOLLABORATE_VERSION}"
    echo "Autonomous Multi-Agent Development Framework"
}

cmd_prompt() {
    cat << 'EOF'
# KOLLABORATE AI ASSISTANT CONTEXT

## What is Kollaborate?

Kollaborate is an autonomous multi-agent development framework that orchestrates multiple AI agents working in parallel on complex software projects. It uses a task-based workflow with typed specifications and automatic agent spawning.

## Project Status Detection

Check if the current directory is a Kollaborate project:
```bash
ls TASK_TRACKING.md    # If exists, project is initialized
```

## Setup for NEW Projects

```bash
# 1. Initialize Kollaborate
kollaborate init

# 2. Switch LLM backend (if not using claude)
kollaborate use gemini    # or: claude, crush, codex, opencode, cursor

# 3. Start the agent watcher daemon
kollaborate start 3 2     # 3 task agents, 2 spec agents
```

## Setup for EXISTING Kollaborate Projects

```bash
# 1. Check current status
kollaborate status

# 2. Check/switch LLM backend if needed
kollaborate use           # Shows current backend
kollaborate use gemini    # Switch if needed

# 3. Start the daemon
kollaborate start 3 2
```

## Task Management

### Add Tasks
```bash
kollaborate add feature "User authentication" src/auth.js
kollaborate add bug "Fix memory leak" src/pool.js
kollaborate add test "Add integration tests" tests/api.test.js
```

### Task Types (17 types available)

**IMPORTANT: Each task type has a SPECIFIC purpose. Using the wrong type (especially R## for everything) will cause issues.**

- **F## (feature)** - NEW functionality that didn't exist before
  - Examples: "Add user login", "Implement payment processing", "Create dashboard"
  - NOT for: Fixing bugs, testing, refactoring existing code

- **R## (refactor)** - RESTRUCTURING existing code WITHOUT changing behavior
  - Examples: "Extract helper functions", "Rename variables for clarity", "Reorganize modules"
  - NOT for: Adding features, fixing bugs, debugging, verifying functionality

- **B## (bug)** - FIXING incorrect behavior or errors
  - Examples: "Fix memory leak", "Debug crash on startup", "Resolve login failure"
  - NOT for: Adding features, refactoring, verification tasks

- **T## (test)** - ADDING or improving tests
  - Examples: "Add unit tests", "Verify integration works", "Test edge cases"
  - NOT for: Debugging bugs, adding features, refactoring

- **D## (doc)** - DOCUMENTATION only
  - Examples: "Write API docs", "Add README", "Document configuration"
  - NOT for: Code changes, testing

- **P## (perf)** - PERFORMANCE optimization
  - Examples: "Optimize database queries", "Reduce bundle size", "Cache frequently accessed data"

- **A## (arch)** - ARCHITECTURE and design decisions
  - Examples: "Design authentication system", "Plan microservices structure"

- **S## (security)** - SECURITY hardening
  - Examples: "Add input sanitization", "Implement rate limiting", "Audit for vulnerabilities"

- **H## (hotfix)** - URGENT production fixes
  - Examples: "Fix production crash", "Patch security vulnerability NOW"

- **M## (migration)** - DATABASE schema changes
  - Examples: "Add users table", "Migrate to new schema", "Data transformation script"

- **I## (integration)** - THIRD-PARTY service integration
  - Examples: "Integrate Stripe", "Add Slack webhooks", "Connect to AWS S3"

- **C## (chore)** - MAINTENANCE tasks
  - Examples: "Update dependencies", "Clean up old files", "Upgrade Node version"

- **E## (experiment)** - PROOF-OF-CONCEPT work
  - Examples: "Spike: Test WebAssembly performance", "POC: Real-time collaboration"

- **U## (ux)** - USER EXPERIENCE improvements
  - Examples: "Improve button accessibility", "Add loading indicators", "Enhance mobile layout"

- **V## (validation)** - DATA VALIDATION logic
  - Examples: "Add email validation", "Enforce password rules", "Validate API inputs"

- **W## (workflow)** - CI/CD and automation
  - Examples: "Setup GitHub Actions", "Add deployment pipeline", "Automate testing"

- **X## (exploration)** - RESEARCH and investigation
  - Examples: "Research best practices", "Investigate performance issue", "Explore alternative approaches"

### Task Format in TASK_TRACKING.md

**Required Format:**
```
STATE: TYPE## - Description (file: path/to/file.ext)
```

**Components:**
- **STATE**: NEW, WORKING, DONE, QA, or BLOCKED
- **TYPE##**: Task type prefix (F, R, B, T, etc.) + sequential number
- **Description**: Clear task description
- **(file: path)**: REQUIRED - Target file path

**Real-World Examples:**
```
DONE: T1 - Add comprehensive security tests (file: src/tests/security.test.js)
DONE: F1 - Implement OAuth2 provider integration with Google and GitHub (file: src/services/oauth2Service.js)
DONE: R31 - Create automated MongoDB backup script with retention policy (file: scripts/automated-backup-cli.js)
DONE: F2 - Build role-based access control (RBAC) system with permissions matrix (file: src/models/Role.js)
DONE: T2 - Add comprehensive load testing suite with Artillery or K6 (file: tests/performance/)
DONE: W1 - Setup CI/CD pipeline with GitHub Actions (file: .github/workflows/ci-cd.yml)
DONE: D1 - API endpoint documentation (file: docs/API.md)
DONE: I2 - Create integration with log aggregation system (file: src/utils/logAggregator.js)
DONE: M1 - Build multi-tenant support for authentication microservice (file: src/models/Tenant.js)
DONE: P1 - Implement advanced analytics and reporting dashboard (file: src/services/analyticsService.js)
DONE: S1 - Create comprehensive API key management system (file: src/models/ApiKey.js)
```

**Critical Rules:**
1. **MUST include `(file: path)`** - tasks without file paths are INVALID
2. **Use APPROPRIATE task types** - Don't use R## for everything:
   - NEW features = F## (not R##)
   - Bug fixes = B## (not R##)
   - Tests = T## (not R##)
   - Documentation = D## (not R##)
   - Refactoring = R## (only for code restructuring)
3. **Task numbers are sequential per type**: F01, F02, F03, R01, R02, T01, T02, etc.
4. **State must be**: NEW, WORKING, DONE, QA, or BLOCKED
5. **Description should be concise but clear**

**COMMON MISTAKE: Using R## (refactor) for everything**

**WRONG Examples (DO NOT DO THIS):**
```
❌ NEW: R1 - Replace main.rs with Application struct usage
   Why wrong? Missing (file: path)

❌ NEW: R2 - Debug window creation and wgpu device initialization
   Why wrong? "Debug" = B## (bug fix), NOT R## (refactor)

❌ NEW: R3 - Verify event loop integration
   Why wrong? "Verify" = T## (test), NOT R## (refactor). Also missing (file: path)

❌ NEW: R4 - Debug rendering pipeline TextureAtlas and shader compilation
   Why wrong? "Debug" = B## (bug fix), NOT R## (refactor)

❌ NEW: R5 - Verify font atlas generation and glyph metrics
   Why wrong? "Verify" = T## (test) or X## (exploration), NOT R## (refactor)

❌ NEW: R6 - Debug text positioning and projection matrix
   Why wrong? "Debug" = B## (bug fix), NOT R## (refactor)

❌ NEW: R7 - Verify RenderContext batching and scissor rects
   Why wrong? "Verify" = T## (test), NOT R## (refactor)

❌ NEW: R8 - Verify widget tree structure and Taffy layout bounds
   Why wrong? "Verify" = T## (test), NOT R## (refactor)

❌ NEW: R9 - Debug event dispatch and hit-testing
   Why wrong? "Debug" = B## (bug fix), NOT R## (refactor)

❌ NEW: R10 - Test button interactions hover and click callbacks
   Why wrong? "Test" = T## (test), NOT R## (refactor)

❌ NEW: R11 - Verify focus management and Tab key navigation
   Why wrong? "Verify" = T## (test), NOT R## (refactor)

❌ NEW: R12 - Verify editor content renders with line numbers
   Why wrong? "Verify" = T## (test), NOT R## (refactor)
```

**CORRECT Examples (with proper types and file paths):**
```
✓ NEW: R1 - Replace main.rs with Application struct usage (file: crates/kollabor/src/main.rs)
  Correct: Actually IS refactoring (restructuring code)

✓ NEW: B1 - Debug window creation and wgpu device initialization (file: crates/native_app/src/window.rs)
  Correct: Debugging = B## (bug fix)

✓ NEW: T1 - Verify event loop integration and WindowEvent handling (file: crates/native_app/src/app.rs)
  Correct: Verification = T## (test)

✓ NEW: B2 - Debug rendering pipeline TextureAtlas and shader compilation (file: crates/kollabor-editor/src/gpu/pipeline.rs)
  Correct: Debugging = B## (bug fix)

✓ NEW: X1 - Verify font atlas generation and glyph metrics (file: crates/kollabor-editor/src/gpu/atlas.rs)
  Correct: Investigation/verification = X## (exploration) or T## (test)

✓ NEW: T2 - Test button interactions hover and click callbacks (file: crates/native_app/src/widgets/button.rs)
  Correct: Testing = T## (test)

✓ NEW: T3 - Verify focus management and Tab key navigation (file: crates/native_app/src/widgets/widget.rs)
  Correct: Verification = T## (test)
```

**Quick Decision Guide:**
- Adding NEW functionality? → F## (feature)
- Fixing broken code? → B## (bug)
- Testing/verifying something works? → T## (test) or X## (exploration)
- Restructuring existing code without changing behavior? → R## (refactor)
- Writing docs only? → D## (doc)
- Need it NOW in production? → H## (hotfix)
- Optimizing speed/performance? → P## (perf)
- Third-party integration? → I## (integration)
- Database schema change? → M## (migration)

## Agent Commands (TMUX-based)

```bash
tglm agent-name "task prompt"    # Create agent session
tlist                             # List active agents
tcapture agent-name               # View agent output
tmsg agent-name "message"         # Send message to agent
tstop agent-name                  # Stop agent
```

## Multi-LLM Backend Support

Supported backends with auto-accept modes:
- **claude**: --dangerously-skip-permissions
- **gemini**: --yolo
- **crush**: --yolo
- **codex**: --sandbox danger-full-access
- **opencode**: (no special flags)
- **cursor**: (generic)

Switch backends:
```bash
kollaborate use gemini
export GLM_BACKEND="gemini"    # Use immediately in current shell
```

## Architecture

### Agent Lifecycle
1. NEW tasks → Spec agent generates detailed requirements (min 50 lines)
2. Spec complete → Task agent spawns to implement
3. Activity monitoring → 3-strike idle detection
4. Task complete → Agent cleanup (DONE/QA status)

### Task State Machine
```
NEW → WORKING → DONE/QA
  ↓       ↓
BLOCKED  ← (recycled if agent goes idle)
```

### File Structure
```
project/
├── TASK_TRACKING.md      # Task manifest
└── specs/                # Generated specifications
    ├── F01-auth.md
    ├── R02-refactor.md
    └── T03-tests.md
```

### Daemon Configuration
Edit these in kollaborate.sh (if needed):
- MAX_AGENTS=3              # Concurrent task agents
- MAX_SPEC_AGENTS=2         # Concurrent spec agents
- CHECK_INTERVAL=60         # Monitoring cycle (seconds)
- NEW_TASK_REQUIRED=5       # Min queue size
- SPEC_TIMEOUT=300          # Spec generation timeout

## Common Workflows

### Starting Fresh
```bash
kollaborate init
kollaborate add feature "Initial feature" src/main.js
kollaborate start
```

### Resuming Work
```bash
kollaborate status          # Check current state
tlist                       # Check running agents
kollaborate start           # Restart if needed
```

### Adding Multiple Tasks
```bash
kollaborate add feature "User login" src/auth/login.js
kollaborate add feature "User signup" src/auth/signup.js
kollaborate add test "Auth tests" tests/auth.test.js
kollaborate add doc "API documentation" docs/api.md
```

### Switching LLM Backend
```bash
kollaborate use              # Show current
kollaborate use gemini       # Switch to Gemini
export GLM_BACKEND="gemini"  # Use immediately
```

## Monitoring & Troubleshooting

```bash
# Check task status
kollaborate status

# List active agents
tlist

# View agent output
tcapture agent-name 50    # Last 50 lines

# Send message to agent
tmsg agent-name "Please focus on error handling"

# Stop specific agent
tstop agent-name

# Stop all agents
tlist | grep -v SESSION | awk '{print $1}' | xargs -I {} tstop {}
```

## Key Files

- **TASK_TRACKING.md**: Task manifest with states
- **specs/TYPE##-name.md**: Generated specifications
- **~/.kollaborate/**: Global installation
  - kollaborate (CLI)
  - kollaborate.sh (Daemon)
  - kollab-commands.sh (Agent commands)
  - glm-setup.sh (LLM wrapper)

## Important Notes

1. **Always initialize first**: Run `kollaborate init` for new projects
2. **Check before starting**: Use `kollaborate status` to see current state
3. **One daemon per project**: Don't run multiple daemons in same directory
4. **Task format matters**: Always use "TYPE## - description (file: path)"
5. **Specs are required**: Agents wait for 50+ line specs before starting
6. **Activity monitoring**: Idle agents get 3 warnings before termination

## Help Commands

```bash
kollaborate help      # Show main help
kollaborate version   # Show version
kollaborate prompt    # Show this context (for AI assistants)
```

## Installation (if not installed)

```bash
# Remote installation
curl -fsSL https://raw.githubusercontent.com/maarco/kollaborate/main/install.sh | zsh
source ~/.zshrc

# Local installation
git clone https://github.com/maarco/kollaborate.git
cd kollaborate
./install.sh
source ~/.zshrc
```

---

This context should help AI assistants understand and work with Kollaborate effectively.
EOF
}

cmd_use() {
    local backend="$1"

    if [[ -z "$backend" ]]; then
        # Show current backend and available options
        print_banner
        echo "${BLUE}[CURRENT]${NC} GLM Backend: ${CYAN}${GLM_BACKEND:-claude}${NC}"
        echo ""
        echo "Available backends:"
        echo "  ${LIME}claude${NC}      - Anthropic Claude (--dangerously-skip-permissions)"
        echo "  ${LIME}gemini${NC}      - Google Gemini (--yolo)"
        echo "  ${LIME}crush${NC}       - Crush AI (--yolo)"
        echo "  ${LIME}codex${NC}       - Codex (--sandbox danger-full-access)"
        echo "  ${LIME}opencode${NC}    - OpenCode"
        echo "  ${LIME}cursor${NC}      - Cursor AI"
        echo "  ${LIME}<custom>${NC}    - Any custom LLM CLI"
        echo ""
        echo "Usage: kollaborate use <backend>"
        echo "Example: kollaborate use gemini"
        return 0
    fi

    # Set the backend
    export GLM_BACKEND="$backend"

    # Update shell RC to persist the change
    local shell_rc=""
    if [[ -n "$ZSH_VERSION" ]]; then
        shell_rc="$HOME/.zshrc"
    elif [[ -n "$BASH_VERSION" ]]; then
        shell_rc="$HOME/.bashrc"
    else
        shell_rc="$HOME/.profile"
    fi

    # Remove old GLM_BACKEND export if exists and add new one
    if [[ -f "$shell_rc" ]]; then
        # Create temp file for safe editing (handles symlinks)
        local temp_file=$(mktemp)
        grep -v '^export GLM_BACKEND=' "$shell_rc" > "$temp_file" 2>/dev/null || cat "$shell_rc" > "$temp_file"

        # Add new GLM_BACKEND export after KOLLABORATE_HOME
        if grep -q "export KOLLABORATE_HOME" "$temp_file"; then
            awk -v backend="$backend" '/export KOLLABORATE_HOME/ {print; print "export GLM_BACKEND=\"" backend "\""; next} 1' "$temp_file" > "${temp_file}.new"
            mv "${temp_file}.new" "$temp_file"
        else
            echo "export GLM_BACKEND=\"$backend\"" >> "$temp_file"
        fi

        # Replace original file
        cat "$temp_file" > "$shell_rc"
        rm "$temp_file"
    fi

    echo "${GREEN}[UPDATED]${NC} GLM backend set to: ${CYAN}$backend${NC}"
    echo "${BLUE}[INFO]${NC}    Changes saved to $shell_rc"
    echo ""
    echo "To use immediately in this shell:"
    echo "  ${CYAN}export GLM_BACKEND=\"$backend\"${NC}"
}

# Parse arguments
PROJECT_TYPE=""
MAX_AGENTS=""
MAX_SPEC_AGENTS=""
COMMAND=""
ARGS=()

while [[ $# -gt 0 ]]; do
    case $1 in
        --project-type)
            PROJECT_TYPE="$2"
            shift 2
            ;;
        --max-agents)
            MAX_AGENTS="$2"
            shift 2
            ;;
        --max-spec-agents)
            MAX_SPEC_AGENTS="$2"
            shift 2
            ;;
        init|start|status|add|use|prompt|help|version|-h|--help|-v|--version)
            if [[ -z "$COMMAND" ]]; then
                COMMAND="$1"
            else
                ARGS+=("$1")
            fi
            shift
            ;;
        *)
            ARGS+=("$1")
            shift
            ;;
    esac
done

# Execute command
case "${COMMAND:-help}" in
    init)
        cmd_init
        ;;
    start)
        cmd_start "${MAX_AGENTS:-${ARGS[1]:-3}}" "${MAX_SPEC_AGENTS:-${ARGS[2]:-2}}"
        ;;
    status)
        cmd_status
        ;;
    add)
        cmd_add "${ARGS[1]}" "${ARGS[2]}" "${ARGS[3]}"
        ;;
    use)
        cmd_use "${ARGS[1]}"
        ;;
    prompt)
        cmd_prompt
        ;;
    version|-v|--version)
        cmd_version
        ;;
    help|-h|--help|*)
        print_help
        ;;
esac
